<!DOCTYPE html>
<html>

<head>
  <title>Streaming TTS Reader</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }

    .container {
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    h2 {
      color: #333;
      text-align: center;
      margin-bottom: 30px;
    }

    .header-section {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 15px;
    }

    .usage-info {
      background: #e3f2fd;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #2196F3;
      min-width: 200px;
    }

    .usage-info h4 {
      margin: 0 0 10px 0;
      color: #1976d2;
    }

    .usage-bar {
      width: 100%;
      height: 8px;
      background: #ddd;
      border-radius: 4px;
      overflow: hidden;
      margin: 5px 0;
    }

    .usage-progress {
      height: 100%;
      background: linear-gradient(90deg, #4caf50, #ff9800, #f44336);
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .usage-text {
      font-size: 12px;
      color: #666;
      text-align: center;
    }

    .auth-section {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .login-form {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .login-form input {
      padding: 6px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 12px;
    }

    .auth-btn {
      padding: 6px 12px;
      font-size: 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .login-btn {
      background: #4caf50;
      color: white;
    }

    .logout-btn {
      background: #f44336;
      color: white;
    }

    .auth-btn:hover {
      opacity: 0.8;
    }

    .input-group {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      align-items: center;
      flex-wrap: wrap;
    }

    .tab-container {
      margin-bottom: 20px;
    }

    .tab-buttons {
      display: flex;
      border-bottom: 2px solid #ddd;
      margin-bottom: 20px;
    }

    .tab-button {
      padding: 12px 24px;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      color: #666;
      border-bottom: 3px solid transparent;
      transition: all 0.3s;
    }

    .tab-button.active {
      color: #4caf50;
      border-bottom-color: #4caf50;
    }

    .tab-button:hover {
      color: #4caf50;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .file-upload-container {
      border: 2px dashed #ddd;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      background: #f9f9f9;
      transition: border-color 0.3s;
    }

    .file-upload-container:hover {
      border-color: #4caf50;
    }

    .file-upload-container.dragover {
      border-color: #4caf50;
      background: #e8f5e8;
    }

    .file-input {
      display: none;
    }

    .upload-label {
      cursor: pointer;
      color: #4caf50;
      font-weight: bold;
      font-size: 16px;
    }

    .upload-label:hover {
      text-decoration: underline;
    }

    .pdf-info {
      background: #e3f2fd;
      border: 1px solid #2196F3;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
      display: none;
    }

    .pdf-info.show {
      display: block;
    }

    .pdf-info h4 {
      margin: 0 0 10px 0;
      color: #1976d2;
    }

    .pdf-details {
      font-size: 14px;
      color: #666;
    }

    .remove-btn {
      background: #f44336;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      font-size: 12px;
      cursor: pointer;
      margin-top: 10px;
    }

    .remove-btn:hover {
      background: #d32f2f;
    }

    .file-upload-container.uploaded {
      background: #e8f5e8;
      border-color: #4caf50;
      pointer-events: none;
    }

    .file-upload-container.uploaded .upload-label {
      color: #2e7d32;
      font-weight: normal;
    }

    input[type="text"] {
      flex: 1;
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 5px;
      font-size: 14px;
      min-width: 300px;
    }

    select {
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 5px;
      font-size: 14px;
      background: white;
    }

    button {
      padding: 12px 24px;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
    }

    button:hover {
      background: #45a049;
    }

    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }

    .audio-container {
      margin: 20px 0;
    }

    audio {
      width: 100%;
      margin: 10px 0;
    }

    .navigation-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 15px 0;
    }

    .nav-btn {
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.3s;
    }

    .nav-btn:hover {
      background: #1976D2;
    }

    .nav-btn:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }

    .chunk-indicator {
      font-size: 16px;
      font-weight: bold;
      color: #333;
      min-width: 120px;
      text-align: center;
    }

    #progressContainer {
      width: 100%;
      height: 8px;
      background: #ddd;
      border-radius: 4px;
      margin: 15px 0;
      overflow: hidden;
      position: relative;
    }

    #progressBar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #4caf50, #45a049);
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    #bufferedBar {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0%;
      background: rgba(76, 175, 80, 0.3);
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    #timeDisplay {
      font-family: monospace;
      margin: 10px 0;
      text-align: center;
      color: #666;
    }

    .status {
      text-align: center;
      margin: 10px 0;
      padding: 10px;
      border-radius: 5px;
      font-weight: bold;
    }

    .status.loading {
      background: #e3f2fd;
      color: #1976d2;
    }

    .status.playing {
      background: #e8f5e8;
      color: #2e7d32;
    }

    .status.complete {
      background: #f3e5f5;
      color: #7b1fa2;
    }

    .chunk-info {
      text-align: center;
      color: #666;
      font-size: 14px;
      margin: 10px 0;
    }

    .full-audio-container {
      display: none;
      margin-top: 20px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 2px solid #e9ecef;
    }

    .full-audio-container.show {
      display: block;
    }

    .full-audio-title {
      text-align: center;
      color: #333;
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 15px;
    }

    .history-section {
      margin-top: 30px;
    }

    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .refresh-btn {
      background: #2196F3;
      padding: 8px 16px;
      font-size: 12px;
    }

    .refresh-btn:hover {
      background: #1976D2;
    }

    .request-item {
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      transition: box-shadow 0.3s;
    }

    .request-item:hover {
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .request-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
    }

    .request-url {
      color: #007bff;
      text-decoration: none;
      font-weight: bold;
      word-break: break-all;
      flex: 1;
      margin-right: 15px;
    }

    .request-url:hover {
      text-decoration: underline;
    }

    .request-meta {
      text-align: right;
      font-size: 12px;
      color: #666;
      min-width: 120px;
    }

    .request-details {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 14px;
      color: #555;
      flex-wrap: wrap;
      gap: 10px;
    }

    .request-actions {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .play-btn {
      background: #28a745;
      padding: 8px 16px;
      font-size: 12px;
    }

    .play-btn:hover {
      background: #218838;
    }

    .request-audio {
      margin-top: 10px;
      display: none;
    }

    .request-audio.show {
      display: block;
    }

    .no-requests {
      text-align: center;
      color: #666;
      font-style: italic;
      padding: 40px;
    }

    .cost-info {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 12px;
      color: #856404;
    }

    .shared-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 20px 0;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #e9ecef;
    }

    .shared-controls select {
      min-width: 150px;
    }

    .shared-controls button {
      min-width: 120px;
    }

    .debug-btn {
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      font-size: 12px;
      cursor: pointer;
      margin-top: 10px;
    }

    .debug-btn:hover {
      background: #1976D2;
    }
  </style>
</head>

<body>
  <div class="container">
    <h2>Streaming TTS Reader</h2>

    <div class="header-section">
      <div class="usage-info">
        <h4>Usage Limit</h4>
        <div class="usage-bar">
          <div id="usageProgress" class="usage-progress" style="width: 0%"></div>
        </div>
        <div id="usageText" class="usage-text">$0.00 / $15.00</div>
        <div id="usageControls" style="display: none; margin-top: 10px;">
          <button id="resetUsageBtn" class="auth-btn" style="background: #ff9800; margin-right: 5px;">Reset
            Usage</button>
          <button id="changeLimitBtn" class="auth-btn" style="background: #2196F3;">Change Limit</button>
        </div>
      </div>

      <div class="auth-section">
        <div id="loginSection" class="login-form">
          <input type="text" id="username" placeholder="Username" />
          <input type="password" id="password" placeholder="Password" />
          <button id="loginBtn" class="auth-btn login-btn">Login</button>
        </div>
        <div id="logoutSection" style="display: none;">
          <span id="userInfo">Logged in as Lin</span>
          <button id="logoutBtn" class="auth-btn logout-btn">Logout</button>
        </div>
      </div>
    </div>

    <div class="input-group">
      <div class="tab-container">
        <div class="tab-buttons">
          <button class="tab-button active" data-tab="url">URL</button>
          <button class="tab-button" data-tab="pdf">PDF</button>
        </div>
      </div>

      <!-- Shared controls -->
      <div class="shared-controls">
        <select id="service">
          <option value="openai">OpenAI TTS</option>
          <option value="polly">AWS Polly (Cheaper)</option>
        </select>
        <select id="voice">
          <option value="shimmer">Shimmer (Sky)</option>
          <option value="onyx">Onyx (Ember)</option>
          <option value="nova">Nova (Cove)</option>
          <option value="echo">Echo (Breeze)</option>
          <option value="fable">Fable (Juniper)</option>
        </select>
        <button id="readBtn">Read Article</button>
      </div>

      <!-- Tab content -->
      <div class="tab-content active" id="url-tab">
        <input type="text" id="url" placeholder="Enter article URL" />
      </div>
      <div class="tab-content" id="pdf-tab">
        <div class="file-upload-container" id="uploadContainer">
          <input type="file" id="pdfFile" class="file-input" accept=".pdf">
          <label for="pdfFile" class="upload-label">Drag and drop PDF here or click to upload</label>
        </div>
        <div id="pdfInfo" class="pdf-info">
          <h4>PDF Information</h4>
          <div class="pdf-details">
            <!-- PDF details will be populated here -->
          </div>
          <button id="removePdfBtn" class="remove-btn">Remove PDF</button>
          <button id="testSessionBtn" class="debug-btn">Test Session</button>
        </div>
      </div>
    </div>

    <div id="status" class="status" style="display: none;"></div>

    <div class="audio-container">
      <audio id="player" controls preload="metadata"></audio>

      <div class="navigation-controls">
        <button id="prevChunkBtn" class="nav-btn" disabled>‚Üê</button>
        <div id="chunkIndicator" class="chunk-indicator">Chunk 0/0</div>
        <button id="nextChunkBtn" class="nav-btn" disabled>‚Üí</button>
      </div>

      <div id="progressContainer">
        <div id="bufferedBar"></div>
        <div id="progressBar"></div>
      </div>

      <div id="timeDisplay">Ready to start</div>
      <div id="chunkInfo" class="chunk-info"></div>
    </div>

    <div id="fullAudioContainer" class="full-audio-container">
      <div class="full-audio-title">Complete Audio</div>
      <audio id="fullAudioPlayer" controls></audio>
    </div>
  </div>

  <div class="container history-section">
    <div class="history-header">
      <h3>Past Audio Requests</h3>
      <button id="refreshHistoryBtn" class="refresh-btn">Refresh</button>
    </div>
    <div id="requestsList"></div>
  </div>

  <script>
    const readBtn = document.getElementById("readBtn");
    const urlInput = document.getElementById("url");
    const serviceSelect = document.getElementById("service");
    const voiceSelect = document.getElementById("voice");
    const player = document.getElementById("player");
    const progressBar = document.getElementById("progressBar");
    const bufferedBar = document.getElementById("bufferedBar");
    const timeDisplay = document.getElementById("timeDisplay");
    const statusDiv = document.getElementById("status");
    const chunkInfo = document.getElementById("chunkInfo");
    const prevChunkBtn = document.getElementById("prevChunkBtn");
    const nextChunkBtn = document.getElementById("nextChunkBtn");
    const chunkIndicator = document.getElementById("chunkIndicator");
    const fullAudioContainer = document.getElementById("fullAudioContainer");
    const fullAudioPlayer = document.getElementById("fullAudioPlayer");
    const refreshHistoryBtn = document.getElementById("refreshHistoryBtn");
    const requestsList = document.getElementById("requestsList");
    const usageProgress = document.getElementById("usageProgress");
    const usageText = document.getElementById("usageText");
    const loginBtn = document.getElementById("loginBtn");
    const logoutBtn = document.getElementById("logoutBtn");
    const loginSection = document.getElementById("loginSection");
    const logoutSection = document.getElementById("logoutSection");
    const userInfo = document.getElementById("userInfo");
    const usageControls = document.getElementById("usageControls");
    const resetUsageBtn = document.getElementById("resetUsageBtn");
    const changeLimitBtn = document.getElementById("changeLimitBtn");

    // Tab system elements
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');

    // PDF upload elements
    const pdfFileInput = document.getElementById('pdfFile');
    const fileUploadContainer = document.querySelector('.file-upload-container');
    const uploadContainer = document.getElementById('uploadContainer');
    const pdfInfo = document.getElementById('pdfInfo');
    const pdfDetails = pdfInfo.querySelector('.pdf-details');
    const removePdfBtn = document.getElementById('removePdfBtn');
    const testSessionBtn = document.getElementById('testSessionBtn');

    let eventSource = null;
    let currentSessionId = null;
    let totalDuration = 0;
    let isStreaming = false;
    let audioQueue = []; // Array of audio chunks to play sequentially
    let currentChunkIndex = 0;
    let isPlaying = false;
    let shouldAutoPlay = false;
    let playedDuration = 0; // Total duration of completed chunks
    let combinedAudioUrl = null; // URL for the complete audio when streaming ends
    let isTransitioningToFullAudio = false; // Flag to track transition state
    let currentPdfFilename = null; // Store current PDF filename

    // Load history and usage on page load
    document.addEventListener('DOMContentLoaded', () => {
      loadHistory();
      loadUsage();
      setupTabs();
      setupPdfUpload();

      // Set up voice options update for service changes
      serviceSelect.addEventListener('change', updateVoiceOptions);
      updateVoiceOptions(); // Initialize voice options
    });

    refreshHistoryBtn.onclick = loadHistory;

    // Update voice options based on selected service
    serviceSelect.onchange = updateVoiceOptions;
    voiceSelect.onchange = updateVoiceOptions;

    function updateVoiceOptions() {
      const selectedService = serviceSelect.value;
      const currentVoice = voiceSelect.value;

      // Clear current options
      voiceSelect.innerHTML = '';

      if (selectedService === 'openai') {
        const openaiVoices = [
          { value: 'shimmer', label: 'Shimmer (Sky)' },
          { value: 'onyx', label: 'Onyx (Ember)' },
          { value: 'nova', label: 'Nova (Cove)' },
          { value: 'echo', label: 'Echo (Breeze)' },
          { value: 'fable', label: 'Fable (Juniper)' }
        ];

        openaiVoices.forEach(voice => {
          const option = document.createElement('option');
          option.value = voice.value;
          option.textContent = voice.label;
          if (voice.value === currentVoice) {
            option.selected = true;
          }
          voiceSelect.appendChild(option);
        });
      } else if (selectedService === 'polly') {
        const pollyVoices = [
          { value: 'joanna', label: 'Joanna (Female, US)' },
          { value: 'matthew', label: 'Matthew (Male, US)' },
          { value: 'ivy', label: 'Ivy (Female, Child)' },
          { value: 'justin', label: 'Justin (Male, Child)' },
          { value: 'kendra', label: 'Kendra (Female, US)' },
          { value: 'kevin', label: 'Kevin (Male, Child)' },
          { value: 'salli', label: 'Salli (Female, US)' },
          { value: 'kimberly', label: 'Kimberly (Female, US)' },
          { value: 'joey', label: 'Joey (Male, US)' },
          { value: 'emma', label: 'Emma (Female, British)' }
        ];

        pollyVoices.forEach(voice => {
          const option = document.createElement('option');
          option.value = voice.value;
          option.textContent = voice.label;
          if (voice.value === currentVoice) {
            option.selected = true;
          }
          voiceSelect.appendChild(option);
        });
      }
    }

    // Initialize voice options
    updateVoiceOptions();

    async function loadUsage() {
      try {
        const response = await fetch('/api/usage');
        const usage = await response.json();
        updateUsageDisplay(usage);
        updateAuthDisplay(usage.isAuthenticated);
      } catch (error) {
        console.error('Error loading usage:', error);
      }
    }

    function updateUsageDisplay(usage) {
      const percentage = (usage.currentUsage / usage.usageLimit) * 100;
      usageProgress.style.width = `${Math.min(percentage, 100)}%`;
      usageText.textContent = `$${usage.currentUsage} / $${usage.usageLimit}`;

      // Change color based on usage level
      if (percentage > 80) {
        usageProgress.style.background = '#f44336'; // Red
      } else if (percentage > 60) {
        usageProgress.style.background = '#ff9800'; // Orange
      } else {
        usageProgress.style.background = 'linear-gradient(90deg, #4caf50, #ff9800, #f44336)';
      }
    }

    function updateAuthDisplay(isAuthenticated) {
      if (isAuthenticated) {
        loginSection.style.display = 'none';
        logoutSection.style.display = 'flex';
        usageControls.style.display = 'block';
      } else {
        loginSection.style.display = 'flex';
        logoutSection.style.display = 'none';
        usageControls.style.display = 'none';
      }
    }

    loginBtn.onclick = async () => {
      const username = document.getElementById('username').value;
      const password = document.getElementById('password').value;

      if (!username || !password) {
        alert('Please enter both username and password');
        return;
      }

      // Show loading state
      loginBtn.disabled = true;
      loginBtn.textContent = 'Logging in...';

      try {
        console.log('Attempting login...');
        const response = await fetch('/api/login', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ username, password })
        });

        console.log('Response status:', response.status);
        console.log('Response headers:', response.headers);

        const responseText = await response.text();
        console.log('Response text:', responseText);

        let result;
        try {
          result = JSON.parse(responseText);
        } catch (e) {
          console.error('Failed to parse JSON response:', responseText);
          alert('Server returned invalid response. Check console for details.');
          return;
        }

        if (result.success) {
          alert('Login successful!');
          loadUsage(); // Refresh usage to update auth status
        } else {
          alert('Login failed: ' + result.message);
        }
      } catch (error) {
        console.error('Login error:', error);
        alert('Login error: ' + error.message);
      } finally {
        // Reset button state
        loginBtn.disabled = false;
        loginBtn.textContent = 'Login';
      }
    };

    logoutBtn.onclick = async () => {
      try {
        const response = await fetch('/api/logout', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          }
        });

        const result = await response.json();

        if (result.success) {
          alert('Logout successful!');
          loadUsage(); // Refresh usage to update auth status
        }
      } catch (error) {
        alert('Logout error: ' + error.message);
      }
    };

    resetUsageBtn.onclick = async () => {
      if (!confirm('Are you sure you want to reset the usage to $0.00?')) {
        return;
      }

      try {
        const response = await fetch('/api/usage', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ action: 'reset' })
        });

        const result = await response.json();

        if (result.success) {
          alert(result.message);
          loadUsage(); // Refresh usage display
        } else {
          alert('Failed to reset usage: ' + result.message);
        }
      } catch (error) {
        alert('Error resetting usage: ' + error.message);
      }
    };

    changeLimitBtn.onclick = async () => {
      const newLimit = prompt('Enter new usage limit (in dollars):', '15.00');

      if (newLimit === null) {
        return; // User cancelled
      }

      const limitValue = parseFloat(newLimit);
      if (isNaN(limitValue) || limitValue < 0) {
        alert('Please enter a valid positive number');
        return;
      }

      try {
        const response = await fetch('/api/usage', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ action: 'set_limit', limit: limitValue })
        });

        const result = await response.json();

        if (result.success) {
          alert(result.message);
          loadUsage(); // Refresh usage display
        } else {
          alert('Failed to change limit: ' + result.message);
        }
      } catch (error) {
        alert('Error changing limit: ' + error.message);
      }
    };

    async function loadHistory() {
      try {
        const response = await fetch('/api/requests');
        const requests = await response.json();
        displayRequests(requests);
      } catch (error) {
        console.error('Error loading history:', error);
        requestsList.innerHTML = '<div class="no-requests">Error loading history</div>';
      }
    }

    function displayRequests(requests) {
      if (requests.length === 0) {
        requestsList.innerHTML = '<div class="no-requests">No past requests found</div>';
        return;
      }

      requestsList.innerHTML = requests.map(request => `
        <div class="request-item">
          <div class="request-header">
            <a href="${request.url}" target="_blank" class="request-url">${request.url}</a>
            <div class="request-meta">
              ${formatTimestamp(request.timestamp)}
            </div>
          </div>
          <div class="request-details">
            <span>Service: ${request.service === 'openai' ? 'OpenAI TTS' : 'AWS Polly'}</span>
            <span>Voice: ${request.voice}</span>
            <span>Chunks: ${request.totalChunks}</span>
            <span>Duration: ${formatTime(request.totalDuration)}</span>
            <span class="cost-info">Cost: $${request.cost.toFixed(4)}</span>
          </div>
          <div class="request-actions">
            <button class="play-btn" onclick="playRequestAudio('${request.sessionId}', '${request.combinedAudioUrl}')">
              Play Full Audio
            </button>
          </div>
          <div id="audio-${request.sessionId}" class="request-audio">
            <audio controls src="${request.combinedAudioUrl}"></audio>
          </div>
        </div>
      `).join('');
    }

    function playRequestAudio(sessionId, audioUrl) {
      const audioContainer = document.getElementById(`audio-${sessionId}`);
      const audioElement = audioContainer.querySelector('audio');

      if (audioContainer.classList.contains('show')) {
        audioContainer.classList.remove('show');
      } else {
        // Hide all other audio players
        document.querySelectorAll('.request-audio').forEach(container => {
          container.classList.remove('show');
        });

        // Show this audio player
        audioContainer.classList.add('show');
        audioElement.play().catch(e => console.log('Auto-play prevented:', e));
      }
    }

    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleString();
    }

    readBtn.onclick = () => {
      const activeTab = document.querySelector('.tab-button.active').getAttribute('data-tab');

      if (activeTab === 'url') {
        handleUrlRequest();
      } else if (activeTab === 'pdf') {
        handlePdfRequest();
      }
    };

    function handleUrlRequest() {
      const articleUrl = urlInput.value.trim();
      const selectedService = serviceSelect.value;
      const selectedVoice = voiceSelect.value;

      if (!articleUrl) {
        alert("Please enter a URL");
        return;
      }

      startStreaming('/stream-read', {
        url: articleUrl,
        service: selectedService,
        voice: selectedVoice
      });
    }

    function handlePdfRequest() {
      if (!currentPdfFilename) {
        alert("Please upload a PDF first");
        return;
      }

      const selectedService = serviceSelect.value;
      const selectedVoice = voiceSelect.value;

      startStreaming('/stream-pdf', {
        service: selectedService,
        voice: selectedVoice
      });
    }

    function startStreaming(endpoint, params) {
      // Reset state
      isStreaming = false;
      totalDuration = 0;
      currentSessionId = null;
      audioQueue = [];
      currentChunkIndex = 0;
      isPlaying = false;
      shouldAutoPlay = false;
      playedDuration = 0;
      combinedAudioUrl = null;
      isTransitioningToFullAudio = false;
      player.src = "";
      fullAudioContainer.classList.remove("show");
      showChunkUI(); // Show chunk UI for new request
      updateDisplay();
      updateNavigationControls();
      updateStatus("loading", "Loading article...");

      readBtn.disabled = true;
      readBtn.textContent = "Loading...";

      // Build streaming URL with query params
      const streamUrl = new URL(endpoint, window.location.origin);
      Object.keys(params).forEach(key => {
        streamUrl.searchParams.set(key, params[key]);
      });

      eventSource = new EventSource(streamUrl);

      eventSource.onopen = () => {
        console.log("Streaming connection opened");
        updateStatus("loading", "Processing article...");
      };

      eventSource.onmessage = (event) => {
        const data = JSON.parse(event.data);

        if (data.audioUrl) {
          // Add the new chunk to our queue
          audioQueue.push({
            url: data.audioUrl,
            duration: data.chunkDuration,
            chunkIndex: data.chunkIndex,
            totalChunks: data.totalChunks
          });

          currentSessionId = data.sessionId;
          isStreaming = true;
          totalDuration = data.totalDuration;

          // If this is the first chunk, start playing
          if (audioQueue.length === 1) {
            playCurrentChunk();
          }

          updateDisplay();
          updateNavigationControls();
          updateStatus("playing", `Processing chunk ${data.chunkIndex + 1} of ${data.totalChunks}`);
          updateChunkInfo(data.chunkIndex + 1, data.totalChunks, data.chunkDuration);
        }
      };

      eventSource.addEventListener("end", () => {
        console.log("Streaming ended");
        eventSource.close();
        readBtn.disabled = false;
        const activeTab = document.querySelector('.tab-button.active').getAttribute('data-tab');
        readBtn.textContent = activeTab === 'pdf' ? "Read PDF" : "Read Article";
        isStreaming = false;
        updateStatus("complete", "Audio generation complete!");
        updateChunkInfo();

        // Create combined audio URL and show full audio player
        if (audioQueue.length > 0) {
          combinedAudioUrl = `/static/combined_${currentSessionId}.mp3`;
          showFullAudio();

          // If currently playing the last chunk, transition to full audio
          if (isPlaying && currentChunkIndex === audioQueue.length - 1) {
            transitionToFullAudio();
          }

          // Hide chunk-related UI elements
          hideChunkUI();
        }

        // Refresh history and usage to show the new request
        loadHistory();
        loadUsage();
      });

      eventSource.addEventListener("error", (event) => {
        console.log("EventSource error event:", event);

        // Try to parse error data if available
        if (event.data) {
          try {
            const errorData = JSON.parse(event.data);
            console.error("Streaming error:", errorData);
            alert("Error: " + errorData.error);
          } catch (e) {
            console.error("Failed to parse error data:", event.data);
            alert("A streaming error occurred. Check console for details.");
          }
        } else {
          console.error("EventSource error without data");
          alert("A streaming error occurred. Please check your internet connection and try again.");
        }

        eventSource.close();
        readBtn.disabled = false;
        const activeTab = document.querySelector('.tab-button.active').getAttribute('data-tab');
        readBtn.textContent = activeTab === 'pdf' ? "Read PDF" : "Read Article";
        updateStatus("loading", "Error occurred");
      });
    }

    function playCurrentChunk() {
      if (currentChunkIndex >= audioQueue.length) {
        isPlaying = false;
        return;
      }

      const currentChunk = audioQueue[currentChunkIndex];
      player.src = currentChunk.url;
      isPlaying = true;

      // Auto-play if user had started playing before
      if (shouldAutoPlay) {
        player.play().catch(e => console.log("Auto-play prevented:", e));
      }

      updateDisplay();
      updateNavigationControls();
    }

    function playNextChunk() {
      // Add the duration of the completed chunk to played duration
      if (currentChunkIndex < audioQueue.length) {
        playedDuration += audioQueue[currentChunkIndex].duration;
      }

      currentChunkIndex++;
      if (currentChunkIndex < audioQueue.length) {
        playCurrentChunk();
      } else {
        isPlaying = false;
        updateDisplay();
        updateNavigationControls();
      }
    }

    function playPreviousChunk() {
      if (currentChunkIndex > 0) {
        // Subtract the duration of the current chunk from played duration
        if (currentChunkIndex < audioQueue.length) {
          playedDuration -= audioQueue[currentChunkIndex].duration;
        }

        currentChunkIndex--;
        playCurrentChunk();
      }
    }

    function jumpToChunk(chunkIndex) {
      if (chunkIndex >= 0 && chunkIndex < audioQueue.length) {
        // Calculate played duration up to the target chunk
        playedDuration = 0;
        for (let i = 0; i < chunkIndex; i++) {
          playedDuration += audioQueue[i].duration;
        }

        currentChunkIndex = chunkIndex;
        playCurrentChunk();
      }
    }

    function showFullAudio() {
      if (combinedAudioUrl) {
        fullAudioContainer.classList.add("show");
        // Note: The main player will be switched to the full audio via transitionToFullAudio()
      }
    }

    function transitionToFullAudio() {
      if (!combinedAudioUrl || isTransitioningToFullAudio) return;

      console.log("Transitioning to full audio...");
      isTransitioningToFullAudio = true;

      // Calculate the current position in the full audio
      const currentTimeInFullAudio = playedDuration + (player.currentTime || 0);

      console.log(`Transition details:
        - playedDuration: ${playedDuration}s (completed chunks)
        - current chunk time: ${player.currentTime || 0}s
        - total position: ${currentTimeInFullAudio}s
        - current chunk index: ${currentChunkIndex}
        - total chunks: ${audioQueue.length}`);

      // Store the current playing state
      const wasPlaying = !player.paused;

      // Switch the main player to the full audio
      player.src = combinedAudioUrl;

      // Wait for the audio to load, then set the position and play
      player.onloadedmetadata = () => {
        player.currentTime = currentTimeInFullAudio;

        if (wasPlaying) {
          player.play().then(() => {
            console.log("Successfully transitioned to full audio at position:", currentTimeInFullAudio);
            isTransitioningToFullAudio = false;
          }).catch(e => {
            console.log("Auto-play prevented for full audio:", e);
            isTransitioningToFullAudio = false;
          });
        } else {
          isTransitioningToFullAudio = false;
        }

        // Reset the onloadedmetadata handler
        player.onloadedmetadata = () => {
          updateDisplay();
        };
      };
    }

    function updateNavigationControls() {
      const totalChunks = audioQueue.length;

      // Update chunk indicator
      chunkIndicator.textContent = `Chunk ${currentChunkIndex + 1}/${totalChunks}`;

      // Update navigation buttons
      prevChunkBtn.disabled = currentChunkIndex <= 0 || totalChunks === 0;
      nextChunkBtn.disabled = currentChunkIndex >= totalChunks - 1 || totalChunks === 0;
    }

    // Navigation button event listeners
    prevChunkBtn.onclick = () => {
      if (currentChunkIndex > 0) {
        playPreviousChunk();
      }
    };

    nextChunkBtn.onclick = () => {
      if (currentChunkIndex < audioQueue.length - 1) {
        playNextChunk();
      }
    };

    // Audio event handlers
    player.ontimeupdate = () => {
      updateDisplay();
    };

    player.onloadedmetadata = () => {
      updateDisplay();
    };

    player.onprogress = () => {
      updateBufferedProgress();
    };

    player.onended = () => {
      // When current chunk ends, play the next one if available
      if (isStreaming && currentChunkIndex < audioQueue.length - 1) {
        playNextChunk();
      } else if (currentChunkIndex < audioQueue.length) {
        // This was the last chunk
        currentChunkIndex++;
        isPlaying = false;

        // If streaming has ended and we have full audio, transition to it
        if (!isStreaming && combinedAudioUrl && !isTransitioningToFullAudio) {
          transitionToFullAudio();
        } else {
          // Only add to playedDuration if we're not transitioning
          playedDuration += audioQueue[currentChunkIndex - 1].duration;
        }

        updateDisplay();
        updateNavigationControls();
      }
    };

    player.onplay = () => {
      shouldAutoPlay = true;
      isPlaying = true;
    };

    player.onpause = () => {
      isPlaying = false;
    };

    function updateDisplay() {
      if (!player.duration || isNaN(player.duration)) {
        timeDisplay.textContent = "Ready to start";
        progressBar.style.width = "0%";
        return;
      }

      const currentTime = player.currentTime || 0;
      const duration = player.duration || 0;

      // If we're streaming, calculate total elapsed time (completed chunks + current chunk progress)
      if (isStreaming) {
        const totalElapsed = playedDuration + currentTime;
        const progressPercent = totalDuration > 0 ? (totalElapsed / totalDuration) * 100 : 0;
        progressBar.style.width = Math.min(progressPercent, 100) + "%";
        timeDisplay.textContent = `${formatTime(totalElapsed)} / ${formatTime(totalDuration)}`;
      } else {
        // We're playing the full audio
        const progressPercent = duration > 0 ? (currentTime / duration) * 100 : 0;
        progressBar.style.width = Math.min(progressPercent, 100) + "%";
        timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
      }
    }

    function updateBufferedProgress() {
      if (!player.buffered || player.buffered.length === 0) {
        bufferedBar.style.width = "0%";
        return;
      }

      const bufferedEnd = player.buffered.end(player.buffered.length - 1);
      const duration = player.duration;
      const bufferedPercent = (bufferedEnd / duration) * 100;
      bufferedBar.style.width = bufferedPercent + "%";
    }

    function updateStatus(type, message) {
      statusDiv.className = `status ${type}`;
      statusDiv.textContent = message;
      statusDiv.style.display = "block";
    }

    function updateChunkInfo(currentChunk = null, totalChunks = null, chunkDuration = null) {
      if (currentChunk && totalChunks) {
        chunkInfo.textContent = `Chunk ${currentChunk}/${totalChunks} (${chunkDuration ? chunkDuration.toFixed(1) + 's' : ''})`;
      } else {
        chunkInfo.textContent = "";
      }
    }

    function formatTime(seconds) {
      if (isNaN(seconds)) return "0:00";
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    }

    function hideChunkUI() {
      // Hide chunk-related UI elements
      console.log("Hiding chunk-related UI elements");

      // Hide navigation controls
      document.querySelector('.navigation-controls').style.display = 'none';

      // Hide chunk info
      chunkInfo.style.display = 'none';

      // Hide the "Complete Audio" section since we're using the main player
      fullAudioContainer.style.display = 'none';

      // Update the audio container styling to look cleaner
      const audioContainer = document.querySelector('.audio-container');
      audioContainer.style.border = '2px solid #4caf50';
      audioContainer.style.borderRadius = '8px';
      audioContainer.style.padding = '20px';
      audioContainer.style.backgroundColor = '#f8f9fa';

      // Add a completion title
      let completionTitle = audioContainer.querySelector('.completion-title');
      if (!completionTitle) {
        completionTitle = document.createElement('div');
        completionTitle.className = 'completion-title';
        completionTitle.style.textAlign = 'center';
        completionTitle.style.color = '#2e7d32';
        completionTitle.style.fontSize = '18px';
        completionTitle.style.fontWeight = 'bold';
        completionTitle.style.marginBottom = '15px';
        audioContainer.insertBefore(completionTitle, audioContainer.firstChild);
      }
      completionTitle.textContent = 'üéß Complete Audio Ready';
    }

    function showChunkUI() {
      // Show chunk-related UI elements
      console.log("Showing chunk-related UI elements");

      // Show navigation controls
      document.querySelector('.navigation-controls').style.display = 'flex';

      // Show chunk info
      chunkInfo.style.display = 'block';

      // Reset the audio container styling
      const audioContainer = document.querySelector('.audio-container');
      audioContainer.style.border = 'none';
      audioContainer.style.borderRadius = '0';
      audioContainer.style.padding = '0';
      audioContainer.style.backgroundColor = 'transparent';

      // Remove completion title if it exists
      const completionTitle = audioContainer.querySelector('.completion-title');
      if (completionTitle) {
        completionTitle.remove();
      }
    }

    // Tab system
    function setupTabs() {
      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const tabName = button.getAttribute('data-tab');
          switchTab(tabName);
        });
      });
    }

    function switchTab(tabName) {
      // Update tab buttons
      tabButtons.forEach(btn => btn.classList.remove('active'));
      document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

      // Update tab contents
      tabContents.forEach(content => content.classList.remove('active'));
      document.getElementById(`${tabName}-tab`).classList.add('active');

      // Update button text and state based on active tab
      if (tabName === 'pdf') {
        readBtn.textContent = 'Read PDF';
        readBtn.disabled = !currentPdfFilename; // Disable if no PDF uploaded
      } else {
        readBtn.textContent = 'Read Article';
        readBtn.disabled = false; // Enable for URL mode
        // Clear PDF info when switching to URL tab
        pdfInfo.classList.remove('show');
        currentPdfFilename = null;
      }
    }

    // PDF upload functionality
    function setupPdfUpload() {
      // File input change handler
      pdfFileInput.addEventListener('change', handlePdfUpload);

      // Remove PDF button handler
      removePdfBtn.addEventListener('click', removePdf);

      // Test session button handler
      testSessionBtn.addEventListener('click', testSession);

      // Drag and drop handlers
      fileUploadContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        fileUploadContainer.classList.add('dragover');
      });

      fileUploadContainer.addEventListener('dragleave', () => {
        fileUploadContainer.classList.remove('dragover');
      });

      fileUploadContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        fileUploadContainer.classList.remove('dragover');

        const files = e.dataTransfer.files;
        if (files.length > 0 && files[0].type === 'application/pdf') {
          pdfFileInput.files = files;
          handlePdfUpload();
        }
      });
    }

    async function handlePdfUpload() {
      const file = pdfFileInput.files[0];
      if (!file) return;

      if (!file.name.toLowerCase().endsWith('.pdf')) {
        alert('Please select a PDF file');
        return;
      }

      const formData = new FormData();
      formData.append('file', file);

      try {
        const response = await fetch('/api/upload-pdf', {
          method: 'POST',
          body: formData
        });

        const result = await response.json();

        if (result.success) {
          currentPdfFilename = file.name;
          showPdfInfo(result);
          showPdfUploadedState();
          readBtn.disabled = false; // Enable the read button
          alert(result.message);
        } else {
          alert('PDF upload failed: ' + result.message);
        }
      } catch (error) {
        console.error('PDF upload error:', error);
        alert('PDF upload failed: ' + error.message);
      }
    }

    function showPdfInfo(result) {
      pdfDetails.innerHTML = `
        <p><strong>Filename:</strong> ${result.filename}</p>
        <p><strong>Text Length:</strong> ${result.textLength.toLocaleString()} characters</p>
        <p><strong>Status:</strong> Ready for audio generation</p>
      `;
      pdfInfo.classList.add('show');
    }

    function showPdfUploadedState() {
      uploadContainer.classList.add('uploaded');
      uploadContainer.querySelector('.upload-label').textContent = `PDF uploaded: ${currentPdfFilename}`;
    }

    function removePdf() {
      // Clear the file input
      pdfFileInput.value = '';

      // Reset the upload container
      uploadContainer.classList.remove('uploaded');
      uploadContainer.querySelector('.upload-label').textContent = 'Drag and drop PDF here or click to upload';

      // Hide PDF info
      pdfInfo.classList.remove('show');

      // Clear variables
      currentPdfFilename = null;

      // Disable read button if we're on PDF tab
      const activeTab = document.querySelector('.tab-button.active').getAttribute('data-tab');
      if (activeTab === 'pdf') {
        readBtn.disabled = true;
      }

      // Clear session data on server
      fetch('/api/clear-pdf', { method: 'POST' }).catch(e => console.log('Failed to clear PDF session:', e));
    }

    function testSession() {
      fetch('/api/test-session')
        .then(response => response.json())
        .then(data => {
          console.log('Session test result:', data);
          alert(`Session Test Results:\n` +
            `Session Working: ${data.session_working}\n` +
            `Has PDF Session ID: ${data.has_pdf_session_id}\n` +
            `Has PDF Filename: ${data.has_pdf_filename}\n` +
            `PDF Session ID: ${data.pdf_session_id || 'None'}\n` +
            `PDF Filename: ${data.pdf_filename || 'None'}\n` +
            `PDF Text File: ${data.pdf_text_file || 'None'}\n` +
            `PDF Text File Exists: ${data.pdf_text_file_exists}\n` +
            `PDF Text Length: ${data.pdf_text_length}\n` +
            `Session Keys: ${data.session_keys.join(', ')}`);
        })
        .catch(error => {
          console.error('Session test failed:', error);
          alert('Session test failed: ' + error.message);
        });
    }
  </script>
</body>

</html>