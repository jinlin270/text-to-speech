<!DOCTYPE html>
<html>

<head>
  <title>Streaming TTS Reader</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }

    .container {
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    h2 {
      color: #333;
      text-align: center;
      margin-bottom: 30px;
    }

    .header-section {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 15px;
    }

    .usage-info {
      background: #e3f2fd;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #2196F3;
      min-width: 200px;
    }

    .usage-info h4 {
      margin: 0 0 10px 0;
      color: #1976d2;
    }

    .usage-bar {
      width: 100%;
      height: 8px;
      background: #ddd;
      border-radius: 4px;
      overflow: hidden;
      margin: 5px 0;
    }

    .usage-progress {
      height: 100%;
      background: linear-gradient(90deg, #4caf50, #ff9800, #f44336);
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .usage-text {
      font-size: 12px;
      color: #666;
      text-align: center;
    }

    .auth-section {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .login-form {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .login-form input {
      padding: 6px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 12px;
    }

    .auth-btn {
      padding: 6px 12px;
      font-size: 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .login-btn {
      background: #4caf50;
      color: white;
    }

    .logout-btn {
      background: #f44336;
      color: white;
    }

    .auth-btn:hover {
      opacity: 0.8;
    }

    .input-group {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      align-items: center;
      flex-wrap: wrap;
    }

    input[type="text"] {
      flex: 1;
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 5px;
      font-size: 14px;
      min-width: 300px;
    }

    select {
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 5px;
      font-size: 14px;
      background: white;
    }

    button {
      padding: 12px 24px;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
    }

    button:hover {
      background: #45a049;
    }

    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }

    .audio-container {
      margin: 20px 0;
    }

    audio {
      width: 100%;
      margin: 10px 0;
    }

    .navigation-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 15px 0;
    }

    .nav-btn {
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.3s;
    }

    .nav-btn:hover {
      background: #1976D2;
    }

    .nav-btn:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }

    .chunk-indicator {
      font-size: 16px;
      font-weight: bold;
      color: #333;
      min-width: 120px;
      text-align: center;
    }

    #progressContainer {
      width: 100%;
      height: 8px;
      background: #ddd;
      border-radius: 4px;
      margin: 15px 0;
      overflow: hidden;
      position: relative;
    }

    #progressBar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #4caf50, #45a049);
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    #bufferedBar {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0%;
      background: rgba(76, 175, 80, 0.3);
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    #timeDisplay {
      font-family: monospace;
      margin: 10px 0;
      text-align: center;
      color: #666;
    }

    .status {
      text-align: center;
      margin: 10px 0;
      padding: 10px;
      border-radius: 5px;
      font-weight: bold;
    }

    .status.loading {
      background: #e3f2fd;
      color: #1976d2;
    }

    .status.playing {
      background: #e8f5e8;
      color: #2e7d32;
    }

    .status.complete {
      background: #f3e5f5;
      color: #7b1fa2;
    }

    .chunk-info {
      text-align: center;
      color: #666;
      font-size: 14px;
      margin: 10px 0;
    }

    .full-audio-container {
      display: none;
      margin-top: 20px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 2px solid #e9ecef;
    }

    .full-audio-container.show {
      display: block;
    }

    .full-audio-title {
      text-align: center;
      color: #333;
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 15px;
    }

    .history-section {
      margin-top: 30px;
    }

    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .refresh-btn {
      background: #2196F3;
      padding: 8px 16px;
      font-size: 12px;
    }

    .refresh-btn:hover {
      background: #1976D2;
    }

    .request-item {
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      transition: box-shadow 0.3s;
    }

    .request-item:hover {
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .request-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
    }

    .request-url {
      color: #007bff;
      text-decoration: none;
      font-weight: bold;
      word-break: break-all;
      flex: 1;
      margin-right: 15px;
    }

    .request-url:hover {
      text-decoration: underline;
    }

    .request-meta {
      text-align: right;
      font-size: 12px;
      color: #666;
      min-width: 120px;
    }

    .request-details {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 14px;
      color: #555;
      flex-wrap: wrap;
      gap: 10px;
    }

    .request-actions {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .play-btn {
      background: #28a745;
      padding: 8px 16px;
      font-size: 12px;
    }

    .play-btn:hover {
      background: #218838;
    }

    .request-audio {
      margin-top: 10px;
      display: none;
    }

    .request-audio.show {
      display: block;
    }

    .no-requests {
      text-align: center;
      color: #666;
      font-style: italic;
      padding: 40px;
    }

    .cost-info {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 12px;
      color: #856404;
    }
  </style>
</head>

<body>
  <div class="container">
    <h2>Streaming TTS Reader</h2>

    <div class="header-section">
      <div class="usage-info">
        <h4>Usage Limit</h4>
        <div class="usage-bar">
          <div id="usageProgress" class="usage-progress" style="width: 0%"></div>
        </div>
        <div id="usageText" class="usage-text">$0.00 / $15.00</div>
        <div id="usageControls" style="display: none; margin-top: 10px;">
          <button id="resetUsageBtn" class="auth-btn" style="background: #ff9800; margin-right: 5px;">Reset
            Usage</button>
          <button id="changeLimitBtn" class="auth-btn" style="background: #2196F3;">Change Limit</button>
        </div>
      </div>

      <div class="auth-section">
        <div id="loginSection" class="login-form">
          <input type="text" id="username" placeholder="Username" />
          <input type="password" id="password" placeholder="Password" />
          <button id="loginBtn" class="auth-btn login-btn">Login</button>
        </div>
        <div id="logoutSection" style="display: none;">
          <span id="userInfo">Logged in as Lin</span>
          <button id="logoutBtn" class="auth-btn logout-btn">Logout</button>
        </div>
      </div>
    </div>

    <div class="input-group">
      <input type="text" id="url" placeholder="Enter article URL" />
      <select id="service">
        <option value="openai">OpenAI TTS</option>
        <option value="polly">AWS Polly (Cheaper)</option>
      </select>
      <select id="voice">
        <option value="shimmer">Shimmer (Sky)</option>
        <option value="onyx">Onyx (Ember)</option>
        <option value="nova">Nova (Cove)</option>
        <option value="echo">Echo (Breeze)</option>
        <option value="fable">Fable (Juniper)</option>
      </select>
      <button id="readBtn">Read Article</button>
    </div>

    <div id="status" class="status" style="display: none;"></div>

    <div class="audio-container">
      <audio id="player" controls preload="metadata"></audio>

      <div class="navigation-controls">
        <button id="prevChunkBtn" class="nav-btn" disabled>←</button>
        <div id="chunkIndicator" class="chunk-indicator">Chunk 0/0</div>
        <button id="nextChunkBtn" class="nav-btn" disabled>→</button>
      </div>

      <div id="progressContainer">
        <div id="bufferedBar"></div>
        <div id="progressBar"></div>
      </div>

      <div id="timeDisplay">Ready to start</div>
      <div id="chunkInfo" class="chunk-info"></div>
    </div>

    <div id="fullAudioContainer" class="full-audio-container">
      <div class="full-audio-title">Complete Audio</div>
      <audio id="fullAudioPlayer" controls></audio>
    </div>
  </div>

  <div class="container history-section">
    <div class="history-header">
      <h3>Past Audio Requests</h3>
      <button id="refreshHistoryBtn" class="refresh-btn">Refresh</button>
    </div>
    <div id="requestsList"></div>
  </div>

  <script>
    const readBtn = document.getElementById("readBtn");
    const urlInput = document.getElementById("url");
    const serviceSelect = document.getElementById("service");
    const voiceSelect = document.getElementById("voice");
    const player = document.getElementById("player");
    const progressBar = document.getElementById("progressBar");
    const bufferedBar = document.getElementById("bufferedBar");
    const timeDisplay = document.getElementById("timeDisplay");
    const statusDiv = document.getElementById("status");
    const chunkInfo = document.getElementById("chunkInfo");
    const prevChunkBtn = document.getElementById("prevChunkBtn");
    const nextChunkBtn = document.getElementById("nextChunkBtn");
    const chunkIndicator = document.getElementById("chunkIndicator");
    const fullAudioContainer = document.getElementById("fullAudioContainer");
    const fullAudioPlayer = document.getElementById("fullAudioPlayer");
    const refreshHistoryBtn = document.getElementById("refreshHistoryBtn");
    const requestsList = document.getElementById("requestsList");
    const usageProgress = document.getElementById("usageProgress");
    const usageText = document.getElementById("usageText");
    const loginBtn = document.getElementById("loginBtn");
    const logoutBtn = document.getElementById("logoutBtn");
    const loginSection = document.getElementById("loginSection");
    const logoutSection = document.getElementById("logoutSection");
    const userInfo = document.getElementById("userInfo");
    const usageControls = document.getElementById("usageControls");
    const resetUsageBtn = document.getElementById("resetUsageBtn");
    const changeLimitBtn = document.getElementById("changeLimitBtn");

    let eventSource = null;
    let currentSessionId = null;
    let totalDuration = 0;
    let isStreaming = false;
    let audioQueue = []; // Array of audio chunks to play sequentially
    let currentChunkIndex = 0;
    let isPlaying = false;
    let shouldAutoPlay = false;
    let playedDuration = 0; // Total duration of completed chunks
    let combinedAudioUrl = null; // URL for the complete audio when streaming ends

    // Load history and usage on page load
    document.addEventListener('DOMContentLoaded', () => {
      loadHistory();
      loadUsage();
    });

    refreshHistoryBtn.onclick = loadHistory;

    // Update voice options based on selected service
    serviceSelect.onchange = updateVoiceOptions;
    voiceSelect.onchange = updateVoiceOptions;

    function updateVoiceOptions() {
      const selectedService = serviceSelect.value;
      const currentVoice = voiceSelect.value;

      // Clear current options
      voiceSelect.innerHTML = '';

      if (selectedService === 'openai') {
        const openaiVoices = [
          { value: 'shimmer', label: 'Shimmer (Sky)' },
          { value: 'onyx', label: 'Onyx (Ember)' },
          { value: 'nova', label: 'Nova (Cove)' },
          { value: 'echo', label: 'Echo (Breeze)' },
          { value: 'fable', label: 'Fable (Juniper)' }
        ];

        openaiVoices.forEach(voice => {
          const option = document.createElement('option');
          option.value = voice.value;
          option.textContent = voice.label;
          if (voice.value === currentVoice) {
            option.selected = true;
          }
          voiceSelect.appendChild(option);
        });
      } else if (selectedService === 'polly') {
        const pollyVoices = [
          { value: 'joanna', label: 'Joanna (Female, US)' },
          { value: 'matthew', label: 'Matthew (Male, US)' },
          { value: 'ivy', label: 'Ivy (Female, Child)' },
          { value: 'justin', label: 'Justin (Male, Child)' },
          { value: 'kendra', label: 'Kendra (Female, US)' },
          { value: 'kevin', label: 'Kevin (Male, Child)' },
          { value: 'salli', label: 'Salli (Female, US)' },
          { value: 'kimberly', label: 'Kimberly (Female, US)' },
          { value: 'joey', label: 'Joey (Male, US)' },
          { value: 'emma', label: 'Emma (Female, British)' }
        ];

        pollyVoices.forEach(voice => {
          const option = document.createElement('option');
          option.value = voice.value;
          option.textContent = voice.label;
          if (voice.value === currentVoice) {
            option.selected = true;
          }
          voiceSelect.appendChild(option);
        });
      }
    }

    // Initialize voice options
    updateVoiceOptions();

    async function loadUsage() {
      try {
        const response = await fetch('/api/usage');
        const usage = await response.json();
        updateUsageDisplay(usage);
        updateAuthDisplay(usage.isAuthenticated);
      } catch (error) {
        console.error('Error loading usage:', error);
      }
    }

    function updateUsageDisplay(usage) {
      const percentage = (usage.currentUsage / usage.usageLimit) * 100;
      usageProgress.style.width = `${Math.min(percentage, 100)}%`;
      usageText.textContent = `$${usage.currentUsage} / $${usage.usageLimit}`;

      // Change color based on usage level
      if (percentage > 80) {
        usageProgress.style.background = '#f44336'; // Red
      } else if (percentage > 60) {
        usageProgress.style.background = '#ff9800'; // Orange
      } else {
        usageProgress.style.background = 'linear-gradient(90deg, #4caf50, #ff9800, #f44336)';
      }
    }

    function updateAuthDisplay(isAuthenticated) {
      if (isAuthenticated) {
        loginSection.style.display = 'none';
        logoutSection.style.display = 'flex';
        usageControls.style.display = 'block';
      } else {
        loginSection.style.display = 'flex';
        logoutSection.style.display = 'none';
        usageControls.style.display = 'none';
      }
    }

    loginBtn.onclick = async () => {
      const username = document.getElementById('username').value;
      const password = document.getElementById('password').value;

      if (!username || !password) {
        alert('Please enter both username and password');
        return;
      }

      // Show loading state
      loginBtn.disabled = true;
      loginBtn.textContent = 'Logging in...';

      try {
        console.log('Attempting login...');
        const response = await fetch('/api/login', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ username, password })
        });

        console.log('Response status:', response.status);
        console.log('Response headers:', response.headers);

        const responseText = await response.text();
        console.log('Response text:', responseText);

        let result;
        try {
          result = JSON.parse(responseText);
        } catch (e) {
          console.error('Failed to parse JSON response:', responseText);
          alert('Server returned invalid response. Check console for details.');
          return;
        }

        if (result.success) {
          alert('Login successful!');
          loadUsage(); // Refresh usage to update auth status
        } else {
          alert('Login failed: ' + result.message);
        }
      } catch (error) {
        console.error('Login error:', error);
        alert('Login error: ' + error.message);
      } finally {
        // Reset button state
        loginBtn.disabled = false;
        loginBtn.textContent = 'Login';
      }
    };

    logoutBtn.onclick = async () => {
      try {
        const response = await fetch('/api/logout', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          }
        });

        const result = await response.json();

        if (result.success) {
          alert('Logout successful!');
          loadUsage(); // Refresh usage to update auth status
        }
      } catch (error) {
        alert('Logout error: ' + error.message);
      }
    };

    resetUsageBtn.onclick = async () => {
      if (!confirm('Are you sure you want to reset the usage to $0.00?')) {
        return;
      }

      try {
        const response = await fetch('/api/usage', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ action: 'reset' })
        });

        const result = await response.json();

        if (result.success) {
          alert(result.message);
          loadUsage(); // Refresh usage display
        } else {
          alert('Failed to reset usage: ' + result.message);
        }
      } catch (error) {
        alert('Error resetting usage: ' + error.message);
      }
    };

    changeLimitBtn.onclick = async () => {
      const newLimit = prompt('Enter new usage limit (in dollars):', '15.00');

      if (newLimit === null) {
        return; // User cancelled
      }

      const limitValue = parseFloat(newLimit);
      if (isNaN(limitValue) || limitValue < 0) {
        alert('Please enter a valid positive number');
        return;
      }

      try {
        const response = await fetch('/api/usage', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ action: 'set_limit', limit: limitValue })
        });

        const result = await response.json();

        if (result.success) {
          alert(result.message);
          loadUsage(); // Refresh usage display
        } else {
          alert('Failed to change limit: ' + result.message);
        }
      } catch (error) {
        alert('Error changing limit: ' + error.message);
      }
    };

    async function loadHistory() {
      try {
        const response = await fetch('/api/requests');
        const requests = await response.json();
        displayRequests(requests);
      } catch (error) {
        console.error('Error loading history:', error);
        requestsList.innerHTML = '<div class="no-requests">Error loading history</div>';
      }
    }

    function displayRequests(requests) {
      if (requests.length === 0) {
        requestsList.innerHTML = '<div class="no-requests">No past requests found</div>';
        return;
      }

      requestsList.innerHTML = requests.map(request => `
        <div class="request-item">
          <div class="request-header">
            <a href="${request.url}" target="_blank" class="request-url">${request.url}</a>
            <div class="request-meta">
              ${formatTimestamp(request.timestamp)}
            </div>
          </div>
          <div class="request-details">
            <span>Service: ${request.service === 'openai' ? 'OpenAI TTS' : 'AWS Polly'}</span>
            <span>Voice: ${request.voice}</span>
            <span>Chunks: ${request.totalChunks}</span>
            <span>Duration: ${formatTime(request.totalDuration)}</span>
            <span class="cost-info">Cost: $${request.cost.toFixed(4)}</span>
          </div>
          <div class="request-actions">
            <button class="play-btn" onclick="playRequestAudio('${request.sessionId}', '${request.combinedAudioUrl}')">
              Play Full Audio
            </button>
          </div>
          <div id="audio-${request.sessionId}" class="request-audio">
            <audio controls src="${request.combinedAudioUrl}"></audio>
          </div>
        </div>
      `).join('');
    }

    function playRequestAudio(sessionId, audioUrl) {
      const audioContainer = document.getElementById(`audio-${sessionId}`);
      const audioElement = audioContainer.querySelector('audio');

      if (audioContainer.classList.contains('show')) {
        audioContainer.classList.remove('show');
      } else {
        // Hide all other audio players
        document.querySelectorAll('.request-audio').forEach(container => {
          container.classList.remove('show');
        });

        // Show this audio player
        audioContainer.classList.add('show');
        audioElement.play().catch(e => console.log('Auto-play prevented:', e));
      }
    }

    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleString();
    }

    readBtn.onclick = () => {
      const articleUrl = urlInput.value.trim();
      const selectedService = serviceSelect.value;
      const selectedVoice = voiceSelect.value;

      if (!articleUrl) {
        alert("Please enter a URL");
        return;
      }

      // Reset state
      isStreaming = false;
      totalDuration = 0;
      currentSessionId = null;
      audioQueue = [];
      currentChunkIndex = 0;
      isPlaying = false;
      shouldAutoPlay = false;
      playedDuration = 0;
      combinedAudioUrl = null;
      player.src = "";
      fullAudioContainer.classList.remove("show");
      updateDisplay();
      updateNavigationControls();
      updateStatus("loading", "Loading article...");

      readBtn.disabled = true;
      readBtn.textContent = "Loading...";

      // Build streaming URL with query params
      const streamUrl = new URL("/stream-read", window.location.origin);
      streamUrl.searchParams.set("url", articleUrl);
      streamUrl.searchParams.set("service", selectedService);
      streamUrl.searchParams.set("voice", selectedVoice);

      eventSource = new EventSource(streamUrl);

      eventSource.onopen = () => {
        console.log("Streaming connection opened");
        updateStatus("loading", "Processing article...");
      };

      eventSource.onmessage = (event) => {
        const data = JSON.parse(event.data);

        if (data.audioUrl) {
          // Add the new chunk to our queue
          audioQueue.push({
            url: data.audioUrl,
            duration: data.chunkDuration,
            chunkIndex: data.chunkIndex,
            totalChunks: data.totalChunks
          });

          currentSessionId = data.sessionId;
          isStreaming = true;
          totalDuration = data.totalDuration;

          // If this is the first chunk, start playing
          if (audioQueue.length === 1) {
            playCurrentChunk();
          }

          updateDisplay();
          updateNavigationControls();
          updateStatus("playing", `Processing chunk ${data.chunkIndex + 1} of ${data.totalChunks}`);
          updateChunkInfo(data.chunkIndex + 1, data.totalChunks, data.chunkDuration);
        }
      };

      eventSource.addEventListener("end", () => {
        console.log("Streaming ended");
        eventSource.close();
        readBtn.disabled = false;
        readBtn.textContent = "Read Article";
        isStreaming = false;
        updateStatus("complete", "Audio generation complete!");
        updateChunkInfo();

        // Create combined audio URL and show full audio player
        if (audioQueue.length > 0) {
          combinedAudioUrl = `/static/combined_${currentSessionId}.mp3`;
          showFullAudio();
        }

        // Refresh history and usage to show the new request
        loadHistory();
        loadUsage();
      });

      eventSource.addEventListener("error", (event) => {
        try {
          const errorData = JSON.parse(event.data);
          alert("Error: " + errorData.error);
        } catch {
          alert("A streaming error occurred");
        }
        eventSource.close();
        readBtn.disabled = false;
        readBtn.textContent = "Read Article";
        updateStatus("loading", "Error occurred");
      });
    };

    function playCurrentChunk() {
      if (currentChunkIndex >= audioQueue.length) {
        isPlaying = false;
        return;
      }

      const currentChunk = audioQueue[currentChunkIndex];
      player.src = currentChunk.url;
      isPlaying = true;

      // Auto-play if user had started playing before
      if (shouldAutoPlay) {
        player.play().catch(e => console.log("Auto-play prevented:", e));
      }

      updateDisplay();
      updateNavigationControls();
    }

    function playNextChunk() {
      // Add the duration of the completed chunk to played duration
      if (currentChunkIndex < audioQueue.length) {
        playedDuration += audioQueue[currentChunkIndex].duration;
      }

      currentChunkIndex++;
      if (currentChunkIndex < audioQueue.length) {
        playCurrentChunk();
      } else {
        isPlaying = false;
        updateDisplay();
        updateNavigationControls();
      }
    }

    function playPreviousChunk() {
      if (currentChunkIndex > 0) {
        // Subtract the duration of the current chunk from played duration
        if (currentChunkIndex < audioQueue.length) {
          playedDuration -= audioQueue[currentChunkIndex].duration;
        }

        currentChunkIndex--;
        playCurrentChunk();
      }
    }

    function jumpToChunk(chunkIndex) {
      if (chunkIndex >= 0 && chunkIndex < audioQueue.length) {
        // Calculate played duration up to the target chunk
        playedDuration = 0;
        for (let i = 0; i < chunkIndex; i++) {
          playedDuration += audioQueue[i].duration;
        }

        currentChunkIndex = chunkIndex;
        playCurrentChunk();
      }
    }

    function showFullAudio() {
      if (combinedAudioUrl) {
        fullAudioPlayer.src = combinedAudioUrl;
        fullAudioContainer.classList.add("show");
      }
    }

    function updateNavigationControls() {
      const totalChunks = audioQueue.length;

      // Update chunk indicator
      chunkIndicator.textContent = `Chunk ${currentChunkIndex + 1}/${totalChunks}`;

      // Update navigation buttons
      prevChunkBtn.disabled = currentChunkIndex <= 0 || totalChunks === 0;
      nextChunkBtn.disabled = currentChunkIndex >= totalChunks - 1 || totalChunks === 0;
    }

    // Navigation button event listeners
    prevChunkBtn.onclick = () => {
      if (currentChunkIndex > 0) {
        playPreviousChunk();
      }
    };

    nextChunkBtn.onclick = () => {
      if (currentChunkIndex < audioQueue.length - 1) {
        playNextChunk();
      }
    };

    // Audio event handlers
    player.ontimeupdate = () => {
      updateDisplay();
    };

    player.onloadedmetadata = () => {
      updateDisplay();
    };

    player.onprogress = () => {
      updateBufferedProgress();
    };

    player.onended = () => {
      // When current chunk ends, play the next one if available
      if (isStreaming && currentChunkIndex < audioQueue.length - 1) {
        playNextChunk();
      } else if (currentChunkIndex < audioQueue.length) {
        // This was the last chunk, mark as complete
        playedDuration += audioQueue[currentChunkIndex].duration;
        currentChunkIndex++;
        isPlaying = false;
        updateDisplay();
        updateNavigationControls();
      }
    };

    player.onplay = () => {
      shouldAutoPlay = true;
      isPlaying = true;
    };

    player.onpause = () => {
      isPlaying = false;
    };

    function updateDisplay() {
      if (!player.duration || isNaN(player.duration)) {
        timeDisplay.textContent = "Ready to start";
        progressBar.style.width = "0%";
        return;
      }

      const currentTime = player.currentTime || 0;

      // Calculate total elapsed time (completed chunks + current chunk progress)
      const totalElapsed = playedDuration + currentTime;

      // Update progress bar
      const progressPercent = totalDuration > 0 ? (totalElapsed / totalDuration) * 100 : 0;
      progressBar.style.width = Math.min(progressPercent, 100) + "%";

      // Update time display
      timeDisplay.textContent = `${formatTime(totalElapsed)} / ${formatTime(totalDuration)}`;
    }

    function updateBufferedProgress() {
      if (!player.buffered || player.buffered.length === 0) {
        bufferedBar.style.width = "0%";
        return;
      }

      const bufferedEnd = player.buffered.end(player.buffered.length - 1);
      const duration = player.duration;
      const bufferedPercent = (bufferedEnd / duration) * 100;
      bufferedBar.style.width = bufferedPercent + "%";
    }

    function updateStatus(type, message) {
      statusDiv.className = `status ${type}`;
      statusDiv.textContent = message;
      statusDiv.style.display = "block";
    }

    function updateChunkInfo(currentChunk = null, totalChunks = null, chunkDuration = null) {
      if (currentChunk && totalChunks) {
        chunkInfo.textContent = `Chunk ${currentChunk}/${totalChunks} (${chunkDuration ? chunkDuration.toFixed(1) + 's' : ''})`;
      } else {
        chunkInfo.textContent = "";
      }
    }

    function formatTime(seconds) {
      if (isNaN(seconds)) return "0:00";
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    }
  </script>
</body>

</html>