<!DOCTYPE html>
<html>

<head>
  <title>Streaming TTS Reader</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }

    .container {
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    h2 {
      color: #333;
      text-align: center;
      margin-bottom: 30px;
    }

    .input-group {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      align-items: center;
      flex-wrap: wrap;
    }

    input[type="text"] {
      flex: 1;
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 5px;
      font-size: 14px;
      min-width: 300px;
    }

    select {
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 5px;
      font-size: 14px;
      background: white;
    }

    button {
      padding: 12px 24px;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
    }

    button:hover {
      background: #45a049;
    }

    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }

    .audio-container {
      margin: 20px 0;
    }

    audio {
      width: 100%;
      margin: 10px 0;
    }

    .navigation-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 15px 0;
    }

    .nav-btn {
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.3s;
    }

    .nav-btn:hover {
      background: #1976D2;
    }

    .nav-btn:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }

    .chunk-indicator {
      font-size: 16px;
      font-weight: bold;
      color: #333;
      min-width: 120px;
      text-align: center;
    }

    #progressContainer {
      width: 100%;
      height: 8px;
      background: #ddd;
      border-radius: 4px;
      margin: 15px 0;
      overflow: hidden;
      position: relative;
    }

    #progressBar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #4caf50, #45a049);
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    #bufferedBar {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0%;
      background: rgba(76, 175, 80, 0.3);
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    #timeDisplay {
      font-family: monospace;
      margin: 10px 0;
      text-align: center;
      color: #666;
    }

    .status {
      text-align: center;
      margin: 10px 0;
      padding: 10px;
      border-radius: 5px;
      font-weight: bold;
    }

    .status.loading {
      background: #e3f2fd;
      color: #1976d2;
    }

    .status.playing {
      background: #e8f5e8;
      color: #2e7d32;
    }

    .status.complete {
      background: #f3e5f5;
      color: #7b1fa2;
    }

    .chunk-info {
      text-align: center;
      color: #666;
      font-size: 14px;
      margin: 10px 0;
    }

    .full-audio-container {
      display: none;
      margin-top: 20px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 2px solid #e9ecef;
    }

    .full-audio-container.show {
      display: block;
    }

    .full-audio-title {
      text-align: center;
      color: #333;
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 15px;
    }

    .history-section {
      margin-top: 30px;
    }

    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .refresh-btn {
      background: #2196F3;
      padding: 8px 16px;
      font-size: 12px;
    }

    .refresh-btn:hover {
      background: #1976D2;
    }

    .request-item {
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      transition: box-shadow 0.3s;
    }

    .request-item:hover {
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .request-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
    }

    .request-url {
      color: #007bff;
      text-decoration: none;
      font-weight: bold;
      word-break: break-all;
      flex: 1;
      margin-right: 15px;
    }

    .request-url:hover {
      text-decoration: underline;
    }

    .request-meta {
      text-align: right;
      font-size: 12px;
      color: #666;
      min-width: 120px;
    }

    .request-details {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 14px;
      color: #555;
    }

    .request-actions {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .play-btn {
      background: #28a745;
      padding: 8px 16px;
      font-size: 12px;
    }

    .play-btn:hover {
      background: #218838;
    }

    .request-audio {
      margin-top: 10px;
      display: none;
    }

    .request-audio.show {
      display: block;
    }

    .no-requests {
      text-align: center;
      color: #666;
      font-style: italic;
      padding: 40px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h2>Streaming TTS Reader</h2>

    <div class="input-group">
      <input type="text" id="url" placeholder="Enter article URL" />
      <select id="service">
        <option value="openai">OpenAI TTS</option>
        <option value="polly">AWS Polly (Cheaper)</option>
      </select>
      <select id="voice">
        <option value="shimmer">Shimmer (Sky)</option>
        <option value="onyx">Onyx (Ember)</option>
        <option value="nova">Nova (Cove)</option>
        <option value="echo">Echo (Breeze)</option>
        <option value="fable">Fable (Juniper)</option>
      </select>
      <button id="readBtn">Read Article</button>
    </div>

    <div id="status" class="status" style="display: none;"></div>

    <div class="audio-container">
      <audio id="player" controls preload="metadata"></audio>

      <div class="navigation-controls">
        <button id="prevChunkBtn" class="nav-btn" disabled>←</button>
        <div id="chunkIndicator" class="chunk-indicator">Chunk 0/0</div>
        <button id="nextChunkBtn" class="nav-btn" disabled>→</button>
      </div>

      <div id="progressContainer">
        <div id="bufferedBar"></div>
        <div id="progressBar"></div>
      </div>

      <div id="timeDisplay">Ready to start</div>
      <div id="chunkInfo" class="chunk-info"></div>
    </div>

    <div id="fullAudioContainer" class="full-audio-container">
      <div class="full-audio-title">Complete Audio</div>
      <audio id="fullAudioPlayer" controls></audio>
    </div>
  </div>

  <div class="container history-section">
    <div class="history-header">
      <h3>Past Audio Requests</h3>
      <button id="refreshHistoryBtn" class="refresh-btn">Refresh</button>
    </div>
    <div id="requestsList"></div>
  </div>

  <script>
    const readBtn = document.getElementById("readBtn");
    const urlInput = document.getElementById("url");
    const serviceSelect = document.getElementById("service");
    const voiceSelect = document.getElementById("voice");
    const player = document.getElementById("player");
    const progressBar = document.getElementById("progressBar");
    const bufferedBar = document.getElementById("bufferedBar");
    const timeDisplay = document.getElementById("timeDisplay");
    const statusDiv = document.getElementById("status");
    const chunkInfo = document.getElementById("chunkInfo");
    const prevChunkBtn = document.getElementById("prevChunkBtn");
    const nextChunkBtn = document.getElementById("nextChunkBtn");
    const chunkIndicator = document.getElementById("chunkIndicator");
    const fullAudioContainer = document.getElementById("fullAudioContainer");
    const fullAudioPlayer = document.getElementById("fullAudioPlayer");
    const refreshHistoryBtn = document.getElementById("refreshHistoryBtn");
    const requestsList = document.getElementById("requestsList");

    let eventSource = null;
    let currentSessionId = null;
    let totalDuration = 0;
    let isStreaming = false;
    let audioQueue = []; // Array of audio chunks to play sequentially
    let currentChunkIndex = 0;
    let isPlaying = false;
    let shouldAutoPlay = false;
    let playedDuration = 0; // Total duration of completed chunks
    let combinedAudioUrl = null; // URL for the complete audio when streaming ends

    // Load history on page load
    document.addEventListener('DOMContentLoaded', loadHistory);

    refreshHistoryBtn.onclick = loadHistory;

    // Update voice options based on selected service
    serviceSelect.onchange = updateVoiceOptions;
    voiceSelect.onchange = updateVoiceOptions;

    function updateVoiceOptions() {
      const selectedService = serviceSelect.value;
      const currentVoice = voiceSelect.value;

      // Clear current options
      voiceSelect.innerHTML = '';

      if (selectedService === 'openai') {
        const openaiVoices = [
          { value: 'shimmer', label: 'Shimmer (Sky)' },
          { value: 'onyx', label: 'Onyx (Ember)' },
          { value: 'nova', label: 'Nova (Cove)' },
          { value: 'echo', label: 'Echo (Breeze)' },
          { value: 'fable', label: 'Fable (Juniper)' }
        ];

        openaiVoices.forEach(voice => {
          const option = document.createElement('option');
          option.value = voice.value;
          option.textContent = voice.label;
          if (voice.value === currentVoice) {
            option.selected = true;
          }
          voiceSelect.appendChild(option);
        });
      } else if (selectedService === 'polly') {
        const pollyVoices = [
          { value: 'joanna', label: 'Joanna (Female, US)' },
          { value: 'matthew', label: 'Matthew (Male, US)' },
          { value: 'ivy', label: 'Ivy (Female, Child)' },
          { value: 'justin', label: 'Justin (Male, Child)' },
          { value: 'kendra', label: 'Kendra (Female, US)' },
          { value: 'kevin', label: 'Kevin (Male, Child)' },
          { value: 'salli', label: 'Salli (Female, US)' },
          { value: 'kimberly', label: 'Kimberly (Female, US)' },
          { value: 'joey', label: 'Joey (Male, US)' },
          { value: 'emma', label: 'Emma (Female, British)' }
        ];

        pollyVoices.forEach(voice => {
          const option = document.createElement('option');
          option.value = voice.value;
          option.textContent = voice.label;
          if (voice.value === currentVoice) {
            option.selected = true;
          }
          voiceSelect.appendChild(option);
        });
      }
    }

    // Initialize voice options
    updateVoiceOptions();

    async function loadHistory() {
      try {
        const response = await fetch('/api/requests');
        const requests = await response.json();
        displayRequests(requests);
      } catch (error) {
        console.error('Error loading history:', error);
        requestsList.innerHTML = '<div class="no-requests">Error loading history</div>';
      }
    }

    function displayRequests(requests) {
      if (requests.length === 0) {
        requestsList.innerHTML = '<div class="no-requests">No past requests found</div>';
        return;
      }

      requestsList.innerHTML = requests.map(request => `
        <div class="request-item">
          <div class="request-header">
            <a href="${request.url}" target="_blank" class="request-url">${request.url}</a>
            <div class="request-meta">
              ${formatTimestamp(request.timestamp)}
            </div>
          </div>
          <div class="request-details">
            <span>Service: ${request.service === 'openai' ? 'OpenAI TTS' : 'AWS Polly'}</span>
            <span>Voice: ${request.voice}</span>
            <span>Chunks: ${request.totalChunks}</span>
            <span>Duration: ${formatTime(request.totalDuration)}</span>
          </div>
          <div class="request-actions">
            <button class="play-btn" onclick="playRequestAudio('${request.sessionId}', '${request.combinedAudioUrl}')">
              Play Full Audio
            </button>
          </div>
          <div id="audio-${request.sessionId}" class="request-audio">
            <audio controls src="${request.combinedAudioUrl}"></audio>
          </div>
        </div>
      `).join('');
    }

    function playRequestAudio(sessionId, audioUrl) {
      const audioContainer = document.getElementById(`audio-${sessionId}`);
      const audioElement = audioContainer.querySelector('audio');

      if (audioContainer.classList.contains('show')) {
        audioContainer.classList.remove('show');
      } else {
        // Hide all other audio players
        document.querySelectorAll('.request-audio').forEach(container => {
          container.classList.remove('show');
        });

        // Show this audio player
        audioContainer.classList.add('show');
        audioElement.play().catch(e => console.log('Auto-play prevented:', e));
      }
    }

    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleString();
    }

    readBtn.onclick = () => {
      const articleUrl = urlInput.value.trim();
      const selectedService = serviceSelect.value;
      const selectedVoice = voiceSelect.value;

      if (!articleUrl) {
        alert("Please enter a URL");
        return;
      }

      // Reset state
      isStreaming = false;
      totalDuration = 0;
      currentSessionId = null;
      audioQueue = [];
      currentChunkIndex = 0;
      isPlaying = false;
      shouldAutoPlay = false;
      playedDuration = 0;
      combinedAudioUrl = null;
      player.src = "";
      fullAudioContainer.classList.remove("show");
      updateDisplay();
      updateNavigationControls();
      updateStatus("loading", "Loading article...");

      readBtn.disabled = true;
      readBtn.textContent = "Loading...";

      // Build streaming URL with query params
      const streamUrl = new URL("/stream-read", window.location.origin);
      streamUrl.searchParams.set("url", articleUrl);
      streamUrl.searchParams.set("service", selectedService);
      streamUrl.searchParams.set("voice", selectedVoice);

      eventSource = new EventSource(streamUrl);

      eventSource.onopen = () => {
        console.log("Streaming connection opened");
        updateStatus("loading", "Processing article...");
      };

      eventSource.onmessage = (event) => {
        const data = JSON.parse(event.data);

        if (data.audioUrl) {
          // Add the new chunk to our queue
          audioQueue.push({
            url: data.audioUrl,
            duration: data.chunkDuration,
            chunkIndex: data.chunkIndex,
            totalChunks: data.totalChunks
          });

          currentSessionId = data.sessionId;
          isStreaming = true;
          totalDuration = data.totalDuration;

          // If this is the first chunk, start playing
          if (audioQueue.length === 1) {
            playCurrentChunk();
          }

          updateDisplay();
          updateNavigationControls();
          updateStatus("playing", `Processing chunk ${data.chunkIndex + 1} of ${data.totalChunks}`);
          updateChunkInfo(data.chunkIndex + 1, data.totalChunks, data.chunkDuration);
        }
      };

      eventSource.addEventListener("end", () => {
        console.log("Streaming ended");
        eventSource.close();
        readBtn.disabled = false;
        readBtn.textContent = "Read Article";
        isStreaming = false;
        updateStatus("complete", "Audio generation complete!");
        updateChunkInfo();

        // Create combined audio URL and show full audio player
        if (audioQueue.length > 0) {
          combinedAudioUrl = `/static/combined_${currentSessionId}.mp3`;
          showFullAudio();
        }

        // Refresh history to show the new request
        loadHistory();
      });

      eventSource.addEventListener("error", (event) => {
        try {
          const errorData = JSON.parse(event.data);
          alert("Error: " + errorData.error);
        } catch {
          alert("A streaming error occurred");
        }
        eventSource.close();
        readBtn.disabled = false;
        readBtn.textContent = "Read Article";
        updateStatus("loading", "Error occurred");
      });
    };

    function playCurrentChunk() {
      if (currentChunkIndex >= audioQueue.length) {
        isPlaying = false;
        return;
      }

      const currentChunk = audioQueue[currentChunkIndex];
      player.src = currentChunk.url;
      isPlaying = true;

      // Auto-play if user had started playing before
      if (shouldAutoPlay) {
        player.play().catch(e => console.log("Auto-play prevented:", e));
      }

      updateDisplay();
      updateNavigationControls();
    }

    function playNextChunk() {
      // Add the duration of the completed chunk to played duration
      if (currentChunkIndex < audioQueue.length) {
        playedDuration += audioQueue[currentChunkIndex].duration;
      }

      currentChunkIndex++;
      if (currentChunkIndex < audioQueue.length) {
        playCurrentChunk();
      } else {
        isPlaying = false;
        updateDisplay();
        updateNavigationControls();
      }
    }

    function playPreviousChunk() {
      if (currentChunkIndex > 0) {
        // Subtract the duration of the current chunk from played duration
        if (currentChunkIndex < audioQueue.length) {
          playedDuration -= audioQueue[currentChunkIndex].duration;
        }

        currentChunkIndex--;
        playCurrentChunk();
      }
    }

    function jumpToChunk(chunkIndex) {
      if (chunkIndex >= 0 && chunkIndex < audioQueue.length) {
        // Calculate played duration up to the target chunk
        playedDuration = 0;
        for (let i = 0; i < chunkIndex; i++) {
          playedDuration += audioQueue[i].duration;
        }

        currentChunkIndex = chunkIndex;
        playCurrentChunk();
      }
    }

    function showFullAudio() {
      if (combinedAudioUrl) {
        fullAudioPlayer.src = combinedAudioUrl;
        fullAudioContainer.classList.add("show");
      }
    }

    function updateNavigationControls() {
      const totalChunks = audioQueue.length;

      // Update chunk indicator
      chunkIndicator.textContent = `Chunk ${currentChunkIndex + 1}/${totalChunks}`;

      // Update navigation buttons
      prevChunkBtn.disabled = currentChunkIndex <= 0 || totalChunks === 0;
      nextChunkBtn.disabled = currentChunkIndex >= totalChunks - 1 || totalChunks === 0;
    }

    // Navigation button event listeners
    prevChunkBtn.onclick = () => {
      if (currentChunkIndex > 0) {
        playPreviousChunk();
      }
    };

    nextChunkBtn.onclick = () => {
      if (currentChunkIndex < audioQueue.length - 1) {
        playNextChunk();
      }
    };

    // Audio event handlers
    player.ontimeupdate = () => {
      updateDisplay();
    };

    player.onloadedmetadata = () => {
      updateDisplay();
    };

    player.onprogress = () => {
      updateBufferedProgress();
    };

    player.onended = () => {
      // When current chunk ends, play the next one if available
      if (isStreaming && currentChunkIndex < audioQueue.length - 1) {
        playNextChunk();
      } else if (currentChunkIndex < audioQueue.length) {
        // This was the last chunk, mark as complete
        playedDuration += audioQueue[currentChunkIndex].duration;
        currentChunkIndex++;
        isPlaying = false;
        updateDisplay();
        updateNavigationControls();
      }
    };

    player.onplay = () => {
      shouldAutoPlay = true;
      isPlaying = true;
    };

    player.onpause = () => {
      isPlaying = false;
    };

    function updateDisplay() {
      if (!player.duration || isNaN(player.duration)) {
        timeDisplay.textContent = "Ready to start";
        progressBar.style.width = "0%";
        return;
      }

      const currentTime = player.currentTime || 0;

      // Calculate total elapsed time (completed chunks + current chunk progress)
      const totalElapsed = playedDuration + currentTime;

      // Update progress bar
      const progressPercent = totalDuration > 0 ? (totalElapsed / totalDuration) * 100 : 0;
      progressBar.style.width = Math.min(progressPercent, 100) + "%";

      // Update time display
      timeDisplay.textContent = `${formatTime(totalElapsed)} / ${formatTime(totalDuration)}`;
    }

    function updateBufferedProgress() {
      if (!player.buffered || player.buffered.length === 0) {
        bufferedBar.style.width = "0%";
        return;
      }

      const bufferedEnd = player.buffered.end(player.buffered.length - 1);
      const duration = player.duration;
      const bufferedPercent = (bufferedEnd / duration) * 100;
      bufferedBar.style.width = bufferedPercent + "%";
    }

    function updateStatus(type, message) {
      statusDiv.className = `status ${type}`;
      statusDiv.textContent = message;
      statusDiv.style.display = "block";
    }

    function updateChunkInfo(currentChunk = null, totalChunks = null, chunkDuration = null) {
      if (currentChunk && totalChunks) {
        chunkInfo.textContent = `Chunk ${currentChunk}/${totalChunks} (${chunkDuration ? chunkDuration.toFixed(1) + 's' : ''})`;
      } else {
        chunkInfo.textContent = "";
      }
    }

    function formatTime(seconds) {
      if (isNaN(seconds)) return "0:00";
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    }
  </script>
</body>

</html>